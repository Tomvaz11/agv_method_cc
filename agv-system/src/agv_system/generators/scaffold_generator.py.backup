#!/usr/bin/env python3
"""
ScaffoldGenerator - Gerador especializado para validação de scaffold (Alvo 0).
Foco em estrutura completa de projeto, configurações base e arquivos iniciais.
"""

import re
from typing import List
from pathlib import Path

import sys
sys.path.append(str(Path(__file__).parent.parent))

from core.base_generator import BaseGenerator
from core.validation_rules import ValidationRule


class ScaffoldGenerator(BaseGenerator):
    """Gerador especializado para validação de scaffold completo (Alvo 0)."""
    
    def __init__(self, specs):
        super().__init__(specs)
    
    def generate_rules(self) -> List[ValidationRule]:
        """Gera todas as regras específicas para scaffold."""
        self.rules = []
        
        # Validações estruturais críticas
        self._generate_structure_rules()
        
        # Validações de configuração base
        self._generate_configuration_validation_rules()
        
        # Validações de conteúdo de arquivos críticos
        self._generate_content_validation_rules()
        
        # Validações de dependências base
        self._generate_dependency_validation_rules()
        
        # Validações específicas para Django/React
        self._generate_framework_specific_rules()
        
        # Validações de modelo se multi-tenancy
        if self.specs.multi_tenancy:
            self._generate_multi_tenancy_rules()
        
        # FASE 1: Validações completas de modelos de domínio (UNIVERSAL)
        self._generate_complete_domain_models_rules()
        
            
        # Validações de documentação básica
        self._generate_documentation_rules()
        
        # Validações de Docker/containerização
        self._generate_docker_rules()
        
        # Validações de setup de desenvolvimento
        self._generate_development_setup_rules()
        
        # Validações de docstrings/comentários obrigatórios (escopo scaffolder)
        self._generate_docstring_validation_rules()
        
        # Validações ultra-rigorosas de estrutura detalhada completa
        self._generate_absolute_structure_validation_rules()
        
        return self.rules
    
    def _generate_structure_rules(self):
        """Gera regras estruturais profundas para scaffold."""
        if self.specs.directory_structure:
            rule_code = self._create_directory_validation_code(self.specs.directory_structure)
            self.rules.append(ValidationRule(
                name="validate_directory_structure",
                description="Valida estrutura completa de diretórios conforme Blueprint",
                code=rule_code,
                severity="HIGH",
                category="STRUCTURE"
            ))
    
    def _generate_configuration_validation_rules(self):
        """Gera regras para validar conteúdo específico dos arquivos de configuração."""
        
        # Validação de .gitignore com conteúdo específico
        self._generate_gitignore_content_validation()
        
        # Validação de pyproject.toml com configurações específicas  
        self._generate_pyproject_content_validation()
        
        # Validação de .pre-commit-config.yaml
        self._generate_precommit_content_validation()
        
        # Validação de .env.example
        self._generate_env_example_validation()
    
    def _generate_gitignore_content_validation(self):
        """Valida conteúdo COMPLETO do .gitignore conforme Blueprint exato."""
        rule_code = """
def validate_gitignore_content():
    '''Valida se .gitignore tem conteúdo EXATO do Blueprint (certeza absoluta).'''
    issues = []
    
    gitignore_paths = list(Path('.').rglob('**/.gitignore'))
    if not gitignore_paths:
        issues.append(ValidationIssue(
            file_path=".gitignore",
            issue_type="missing_gitignore_file",
            description="Arquivo .gitignore não encontrado",
            expected="Arquivo .gitignore deve existir na raiz",
            actual="Arquivo não existe",
            severity="CRITICAL"
        ))
        return issues
    
    gitignore_file = gitignore_paths[0]
    content = gitignore_file.read_text(encoding='utf-8', errors='ignore')
    
    # Conteúdo COMPLETO esperado do Blueprint (seção 8)
    expected_blueprint_sections = [
        # Byte-compiled / optimized / DLL files
        '__pycache__/', '*.py[cod]', '*$py.class', '*.so',
        
        # Distribution / packaging
        '.Python', 'build/', 'develop-eggs/', 'dist/', 'downloads/',
        'eggs/', '.eggs/', 'lib/', 'lib64/', 'parts/', 'sdist/',
        'var/', 'wheels/', 'share/python-wheels/', '*.egg-info/',
        '.installed.cfg', '*.egg', 'MANIFEST',
        
        # PyInstaller
        '*.manifest', '*.spec',
        
        # Installer logs  
        'pip-log.txt', 'pip-delete-this-directory.txt',
        
        # Unit test / coverage reports
        'htmlcov/', '.tox/', '.nox/', '.coverage', '.coverage.*',
        '.cache', 'nosetests.xml', 'coverage.xml', '*.cover',
        '*.py,cover', '.hypothesis/', '.pytest_cache/', 'cover/',
        
        # Translations
        '*.mo', '*.pot',
        
        # Django stuff
        '*.log', 'local_settings.py', 'db.sqlite3', 'db.sqlite3-journal',
        
        # Environments
        '.env', '.venv', 'env/', 'venv/', 'ENV/', 'env.bak/', 'venv.bak/',
        
        # IDE files
        '.idea/', '.vscode/', '*.swp', '*.swo',
        
        # Node.js
        'node_modules/', 'dist/', 'dist-ssr/', '*.local',
        'npm-debug.log*', 'yarn-debug.log*', 'yarn-error.log*', 'pnpm-debug.log*',
        
        # Docker
        'docker-compose.override.yml',
        
        # OS files
        '.DS_Store', 'Thumbs.db'
    ]
    
    # Validação RIGOROSA: cada seção deve estar presente
    missing_critical = []
    missing_optional = []
    
    critical_sections = [
        '__pycache__/', '*.py[cod]', 'node_modules/', 'dist/',
        '.env', '.venv', '.idea/', '.vscode/', 'db.sqlite3', '*.log'
    ]
    
    for section in expected_blueprint_sections:
        if section not in content:
            if section in critical_sections:
                missing_critical.append(section)
            else:
                missing_optional.append(section)
    
    # Reportar seções críticas ausentes
    for section in missing_critical:
        issues.append(ValidationIssue(
            file_path=str(gitignore_file),
            issue_type="missing_critical_gitignore_section",
            description=f"Seção CRÍTICA ausente no .gitignore: {section}",
            expected=f"Seção '{section}' é OBRIGATÓRIA conforme Blueprint seção 8",
            actual="Seção crítica não encontrada",
            severity="HIGH"
        ))
    
    # Reportar seções opcionais ausentes (para completude)
    if len(missing_optional) > 5:  # Muitas seções ausentes
        issues.append(ValidationIssue(
            file_path=str(gitignore_file),
            issue_type="incomplete_gitignore_content", 
            description=f"Gitignore incompleto: {len(missing_optional)} seções Blueprint ausentes",
            expected="Conteúdo completo do Blueprint seção 8 deve estar presente",
            actual=f"Faltam seções: {', '.join(missing_optional[:3])}...",
            severity="MEDIUM"
        ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_gitignore_content",
            description="Valida conteúdo específico do arquivo .gitignore",
            code=rule_code.strip(),
            severity="MEDIUM",
            category="CONTENT"
        ))
    
    def _generate_pyproject_content_validation(self):
        """Valida conteúdo específico do pyproject.toml conforme Blueprint."""
        rule_code = """
def validate_pyproject_content():
    '''Valida se pyproject.toml tem configurações específicas do Blueprint.'''
    issues = []
    
    pyproject_paths = list(Path('.').rglob('**/pyproject.toml'))
    # Filtrar arquivos do agv-system
    project_files = [f for f in pyproject_paths if 'agv-system' not in str(f)]
    
    if not project_files:
        issues.append(ValidationIssue(
            file_path="pyproject.toml",
            issue_type="missing_pyproject_file",
            description="Arquivo pyproject.toml não encontrado",
            expected="Arquivo pyproject.toml deve existir no backend",
            actual="Arquivo não existe",
            severity="HIGH"
        ))
        return issues
    
    pyproject_file = project_files[0]
    content = pyproject_file.read_text(encoding='utf-8', errors='ignore')
    
    # Configurações obrigatórias do Blueprint
    required_configs = [
        '[tool.ruff]',     # Linter configuration
        '[tool.black]',    # Formatter configuration  
        'line-length',     # Code style
        'django',          # Django dependency
        'djangorestframework', # DRF dependency
        'psycopg2-binary'  # PostgreSQL driver
    ]
    
    for config in required_configs:
        if config not in content:
            issues.append(ValidationIssue(
                file_path=str(pyproject_file),
                issue_type="missing_pyproject_config",
                description=f"Configuração obrigatória não encontrada: {config}",
                expected=f"Configuração '{config}' deve estar no pyproject.toml conforme Blueprint",
                actual="Configuração não encontrada",
                severity="MEDIUM"
            ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_pyproject_content",
            description="Valida configurações específicas do pyproject.toml",
            code=rule_code.strip(),
            severity="MEDIUM", 
            category="CONTENT"
        ))
    
    def _generate_precommit_content_validation(self):
        """Valida conteúdo específico do .pre-commit-config.yaml."""
        rule_code = """
def validate_precommit_config_content():
    '''Valida se .pre-commit-config.yaml tem configuração específica do Blueprint.'''
    issues = []
    
    precommit_paths = list(Path('.').rglob('**/.pre-commit-config.yaml'))
    if not precommit_paths:
        issues.append(ValidationIssue(
            file_path=".pre-commit-config.yaml",
            issue_type="missing_precommit_config",
            description="Arquivo .pre-commit-config.yaml não encontrado",
            expected="Arquivo deve existir na raiz conforme Blueprint",
            actual="Arquivo não existe",
            severity="MEDIUM"
        ))
        return issues
    
    precommit_file = precommit_paths[0]
    content = precommit_file.read_text(encoding='utf-8', errors='ignore')
    
    # Hooks obrigatórios do Blueprint
    required_hooks = [
        'pre-commit-hooks',  # Basic hooks
        'trailing-whitespace', 'end-of-file-fixer',  # File formatting
        'black',             # Python formatter
        'ruff'               # Python linter
    ]
    
    for hook in required_hooks:
        if hook not in content:
            issues.append(ValidationIssue(
                file_path=str(precommit_file),
                issue_type="missing_precommit_hook",
                description=f"Hook obrigatório não encontrado: {hook}",
                expected=f"Hook '{hook}' deve estar configurado conforme Blueprint",
                actual="Hook não encontrado",
                severity="MEDIUM"
            ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_precommit_config_content",
            description="Valida configuração específica do .pre-commit-config.yaml",
            code=rule_code.strip(),
            severity="MEDIUM",
            category="CONTENT"
        ))
    
    def _generate_env_example_validation(self):
        """Valida arquivo .env.example obrigatório."""
        rule_code = """
def validate_env_example_file():
    '''Valida se .env.example existe conforme escopo scaffolder.'''
    issues = []
    
    env_example_paths = list(Path('.').rglob('**/.env.example'))
    if not env_example_paths:
        issues.append(ValidationIssue(
            file_path=".env.example",
            issue_type="missing_env_example",
            description="Arquivo .env.example não encontrado",
            expected="Template de variáveis de ambiente deve existir",
            actual="Arquivo não existe",
            severity="MEDIUM"
        ))
        return issues
    
    env_file = env_example_paths[0]
    content = env_file.read_text(encoding='utf-8', errors='ignore')
    
    # Variáveis básicas obrigatórias
    basic_vars = ['DEBUG', 'SECRET_KEY', 'DATABASE_URL']
    
    for var in basic_vars:
        if var not in content:
            issues.append(ValidationIssue(
                file_path=str(env_file),
                issue_type="missing_env_variable",
                description=f"Variável de ambiente obrigatória não encontrada: {var}",
                expected=f"Variável '{var}' deve estar no template",
                actual="Variável não encontrada",
                severity="LOW"
            ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_env_example_file",
            description="Valida arquivo template .env.example",
            code=rule_code.strip(),
            severity="MEDIUM",
            category="STRUCTURE"
        ))
    
    def _generate_content_validation_rules(self):
        """Gera regras para validar conteúdo específico de arquivos."""
        for file_path, validations in self.specs.file_content_validations.items():
            rule_code = self._create_content_validation_code(file_path, validations)
            clean_name = re.sub(r'[^\w]', '_', file_path).strip('_')
            
            self.rules.append(ValidationRule(
                name=f"validate_content_{clean_name}",
                description=f"Valida conteúdo específico de {file_path}",
                code=rule_code,
                severity="HIGH",
                category="CONTENT"
            ))
    
    def _generate_dependency_validation_rules(self):
        """Gera regras avançadas para validação de dependências base."""
        # Dependências críticas para scaffold
        critical_backend_deps = ['django', 'djangorestframework', 'psycopg2-binary']
        critical_frontend_deps = ['react', '@types/react']
        
        for dep_name in critical_backend_deps:
            if dep_name in self.specs.specific_dependencies:
                version = self.specs.specific_dependencies[dep_name]
                rule_code = self._create_specific_dependency_validation(dep_name, version)
                clean_name = re.sub(r'[^\w]', '_', dep_name).strip('_')
                
                self.rules.append(ValidationRule(
                    name=f"validate_dependency_{clean_name}",
                    description=f"Valida dependência crítica {dep_name}",
                    code=rule_code,
                    severity="HIGH",
                    category="DEPENDENCIES"
                ))
    
    def _generate_framework_specific_rules(self):
        """Gera regras específicas para Django e React."""
        # Django settings structure validation
        if self.specs.backend_framework == "django":
            rule_code = """
def validate_django_settings_advanced():
    '''Valida configurações avançadas do Django.'''
    issues = []
    
    settings_files = list(Path('.').rglob('**/settings.py'))
    for settings_file in settings_files:
        if settings_file.exists():
            content = settings_file.read_text(encoding='utf-8', errors='ignore')
            
            # Verificações críticas
            critical_settings = [
                'DATABASES', 'INSTALLED_APPS', 'MIDDLEWARE', 
                'ROOT_URLCONF', 'TEMPLATES'
            ]
            
            for setting in critical_settings:
                if setting not in content:
                    issues.append(ValidationIssue(
                        file_path=str(settings_file),
                        issue_type="missing_django_setting",
                        description=f"Configuração Django crítica não encontrada: {setting}",
                        expected=f"{setting} deve estar configurado",
                        actual="Configuração ausente",
                        severity="HIGH"
                    ))
    
    return issues if issues else None
"""
            
            self.rules.append(ValidationRule(
                name="validate_django_settings_advanced",
                description="Valida configurações avançadas do Django",
                code=rule_code.strip(),
                severity="HIGH",
                category="CONTENT"
            ))
        
        # React package.json structure validation  
        if self.specs.frontend_framework == "react":
            rule_code = """
def validate_react_package_structure():
    '''Valida estrutura do package.json para React.'''
    issues = []
    
    package_files = list(Path('.').rglob('**/package.json'))
    for package_file in package_files:
        if package_file.exists():
            try:
                import json
                content = json.loads(package_file.read_text(encoding='utf-8'))
                
                # Verificar dependências React críticas
                deps = content.get('dependencies', {})
                dev_deps = content.get('devDependencies', {})
                all_deps = {**deps, **dev_deps}
                
                critical_react_deps = ['react', 'react-dom']
                for dep in critical_react_deps:
                    if dep not in all_deps:
                        issues.append(ValidationIssue(
                            file_path=str(package_file),
                            issue_type="missing_react_dependency",
                            description=f"Dependência React crítica não encontrada: {dep}",
                            expected=f"{dep} deve estar nas dependências",
                            actual="Dependência ausente",
                            severity="HIGH"
                        ))
                        
            except json.JSONDecodeError:
                issues.append(ValidationIssue(
                    file_path=str(package_file),
                    issue_type="invalid_package_json",
                    description="package.json com formato inválido",
                    expected="JSON válido",
                    actual="JSON inválido",
                    severity="HIGH"
                ))
    
    return issues if issues else None
"""
            
            self.rules.append(ValidationRule(
                name="validate_react_package_structure",
                description="Valida estrutura do package.json para React",
                code=rule_code.strip(),
                severity="HIGH",
                category="DEPENDENCIES"
            ))
    
    def _generate_multi_tenancy_rules(self):
        """Gera regras específicas para multi-tenancy no scaffold."""
        if not self.specs.multi_tenancy:
            return
        
        rule_code = self._create_multi_tenancy_validation_code()
        
        self.rules.append(ValidationRule(
            name="validate_multi_tenancy_implementation",
            description="Valida implementação completa de multi-tenancy no scaffold",
            code=rule_code.strip(),
            severity="CRITICAL",
            category="MODELS"
        ))
    
    def _generate_documentation_rules(self):
        """Gera regras para documentação básica."""
        essential_docs = ["README.md", "LICENSE", "CHANGELOG.md", "CONTRIBUTING.md"]
        
        for doc_file in essential_docs:
            if doc_file in self.specs.documentation_files or doc_file.lower() in [d.lower() for d in self.specs.documentation_files]:
                rule_code = f"""
def validate_{re.sub(r'[^\w]', '_', doc_file).strip('_').lower()}():
    '''Valida existência de {doc_file}.'''
    issues = []
    
    doc_paths = list(Path('.').rglob('**/{doc_file}'))
    if not doc_paths:
        # Tentar variações case-insensitive
        alt_paths = list(Path('.').rglob('**/{doc_file.lower()}'))
        if not alt_paths:
            issues.append(ValidationIssue(
                file_path="{doc_file}",
                issue_type="missing_documentation",
                description="Documentação essencial não encontrada: {doc_file}",
                expected="Arquivo deve existir na raiz do projeto",
                actual="Arquivo não existe",
                severity="MEDIUM"
            ))
    
    return issues if issues else None
"""
                
                self.rules.append(ValidationRule(
                    name=f"validate_{re.sub(r'[^\w]', '_', doc_file).strip('_').lower()}",
                    description=f"Valida documentação essencial {doc_file}",
                    code=rule_code.strip(),
                    severity="MEDIUM",
                    category="CONTENT"
                ))
        
        # Adicionar validação específica de conteúdo do README.md
        self._add_readme_content_validation()
    
    def _add_readme_content_validation(self):
        """Validação ULTRA-RIGOROSA do README.md conforme Blueprint seção 9."""
        rule_code = """
def validate_readme_content_specific():
    '''Valida README.md COMPLETO conforme Blueprint seção 9 (certeza absoluta).'''
    issues = []
    
    readme_paths = list(Path('.').rglob('**/README.md'))
    if not readme_paths:
        return None  # Já validado em outra regra
    
    readme_file = readme_paths[0]
    content = readme_file.read_text(encoding='utf-8', errors='ignore')
    
    # Estrutura EXATA esperada do Blueprint seção 9
    expected_blueprint_structure = [
        # Título e badges obrigatórios
        '# IABANK',
        '[![Status]',
        '[![CI/CD]', 
        '[![License]',
        
        # Seções estruturais obrigatórias 
        '## Sobre o Projeto',
        'Sistema de gestão de empréstimos',
        'plataforma Web SaaS',
        'multi-tenant',
        
        '## Stack Tecnológica',
        '**Backend:** Python',
        '**Frontend:** React',
        '**Banco de Dados:** PostgreSQL',
        '**Cache & Fila de Tarefas:** Redis, Celery',
        '**Containerização:** Docker',
        
        '## Como Começar',
        '### Pré-requisitos',
        'Docker e Docker Compose',
        'Node.js e pnpm',
        'Python e Poetry',
        
        '### Instalação e Execução',
        'git clone',
        '.env.example',
        'docker-compose up',
        'http://localhost:5173',
        'http://localhost:8000/api/',
        
        '## Como Executar os Testes',
        'docker-compose exec backend',
        'pytest'
    ]
    
    # Validação CRÍTICA: elementos essenciais
    critical_missing = []
    important_missing = []
    
    critical_elements = [
        '# IABANK', '## Sobre o Projeto', '## Stack Tecnológica', 
        '## Como Começar', 'Docker', 'docker-compose'
    ]
    
    important_elements = [
        'Python', 'React', 'PostgreSQL', 'Redis', 'git clone',
        'pytest', '[![', 'multi-tenant', 'SaaS'
    ]
    
    # Verificar elementos críticos
    for element in critical_elements:
        if element not in content:
            critical_missing.append(element)
    
    # Verificar elementos importantes
    for element in important_elements:
        if element not in content:
            important_missing.append(element)
    
    # Reportar ausências críticas
    for missing in critical_missing:
        issues.append(ValidationIssue(
            file_path=str(readme_file),
            issue_type="missing_critical_readme_element",
            description=f"Elemento CRÍTICO ausente no README: {missing}",
            expected=f"Elemento '{missing}' é OBRIGATÓRIO conforme Blueprint seção 9",
            actual="Elemento crítico não encontrado",
            severity="HIGH"
        ))
    
    # Reportar ausências importantes (completude)
    if len(important_missing) > 3:
        issues.append(ValidationIssue(
            file_path=str(readme_file),
            issue_type="incomplete_readme_content",
            description=f"README incompleto: {len(important_missing)} elementos Blueprint ausentes",
            expected="Conteúdo completo do Blueprint seção 9 deve estar presente",
            actual=f"Faltam elementos: {', '.join(important_missing[:3])}...",
            severity="MEDIUM"
        ))
    
    # Validar estrutura de seções (ordem e hierarquia)
    lines = content.split('\\n')
    h1_found = any(line.startswith('# ') for line in lines)
    h2_count = sum(1 for line in lines if line.startswith('## '))
    
    if not h1_found:
        issues.append(ValidationIssue(
            file_path=str(readme_file),
            issue_type="missing_main_title",
            description="README sem título principal (# IABANK)",
            expected="Título principal '# IABANK' conforme Blueprint",
            actual="Nenhum título H1 encontrado",
            severity="HIGH"
        ))
    
    if h2_count < 4:  # Mínimo de seções esperadas
        issues.append(ValidationIssue(
            file_path=str(readme_file),
            issue_type="insufficient_readme_sections",
            description=f"README com poucas seções: {h2_count} encontradas",
            expected="Mínimo 4 seções principais conforme Blueprint",
            actual=f"Apenas {h2_count} seções H2 encontradas",
            severity="MEDIUM"
        ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_readme_content_specific",
            description="Valida conteúdo específico do README.md conforme Blueprint",
            code=rule_code.strip(),
            severity="MEDIUM",
            category="CONTENT"
        ))
    
    def _generate_docker_rules(self):
        """Gera regras para configuração Docker."""
        docker_files = ["Dockerfile", "docker-compose.yml", ".dockerignore"]
        
        for docker_file in docker_files:
            if docker_file in self.specs.docker_files:
                rule_code = f"""
def validate_{re.sub(r'[^\w]', '_', docker_file).strip('_')}():
    '''Valida arquivo Docker: {docker_file}.'''
    issues = []
    
    docker_paths = list(Path('.').rglob('**/{docker_file}'))
    if not docker_paths:
        issues.append(ValidationIssue(
            file_path="{docker_file}",
            issue_type="missing_docker_file",
            description="Arquivo Docker não encontrado: {docker_file}",
            expected="Arquivo deve existir para containerização",
            actual="Arquivo não existe",
            severity="MEDIUM"
        ))
    
    return issues if issues else None
"""
                
                self.rules.append(ValidationRule(
                    name=f"validate_{re.sub(r'[^\w]', '_', docker_file).strip('_')}",
                    description=f"Valida arquivo Docker {docker_file}",
                    code=rule_code.strip(),
                    severity="MEDIUM",
                    category="STRUCTURE"
                ))
    
    def _generate_development_setup_rules(self):
        """Gera regras para setup de desenvolvimento."""
        # Validação de ferramentas de qualidade de código
        rule_code = """
def validate_development_quality_tools():
    '''Valida ferramentas de qualidade de código.'''
    issues = []
    
    # Verificar pre-commit
    precommit_paths = list(Path('.').rglob('**/.pre-commit-config.yaml'))
    if not precommit_paths:
        issues.append(ValidationIssue(
            file_path=".pre-commit-config.yaml",
            issue_type="missing_precommit_config",
            description="Configuração pre-commit não encontrada",
            expected="Arquivo .pre-commit-config.yaml deve existir",
            actual="Arquivo não existe",
            severity="MEDIUM"
        ))
    
    # Verificar gitignore
    gitignore_paths = list(Path('.').rglob('**/.gitignore'))
    if not gitignore_paths:
        issues.append(ValidationIssue(
            file_path=".gitignore",
            issue_type="missing_gitignore",
            description="Arquivo .gitignore não encontrado",
            expected="Arquivo .gitignore deve existir",
            actual="Arquivo não existe",
            severity="HIGH"
        ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_development_quality_tools",
            description="Valida ferramentas de qualidade e setup de desenvolvimento",
            code=rule_code.strip(),
            severity="MEDIUM",
            category="STRUCTURE"
        ))

    def _generate_complete_domain_models_rules(self):
        """FASE 1: Gera validações completas e universais para modelos de domínio."""
        if not self.specs.models:
            return
            
        # 1. Validação universal de todos os modelos definidos no Blueprint
        self._generate_universal_models_validation()
        
        # 2. Validação de campos específicos por modelo (universal)
        self._generate_model_docstring_validation()
        
        # 3. Validação de apps Django completos (universal)
        self._generate_apps_structure_validation()
        
        # 4. Validação de frontend React (universal)
        self._generate_frontend_basic_structure_validation()
        
        # 5. Validação de pipeline CI/CD (universal)
        self._generate_github_actions_validation()

    def _generate_universal_models_validation(self):
        """Valida existência de todos os modelos definidos no Blueprint - UNIVERSAL."""
        expected_models = list(self.specs.models.keys())
        
        rule_code = f"""
def validate_all_blueprint_models():
    '''Valida todos os modelos definidos no Blueprint arquitetural.'''
    issues = []
    expected_models = {expected_models}
    
    # Buscar models.py em estruturas Django típicas
    models_files = []
    django_patterns = [
        '**/backend/src/*/models.py',  # iabank/backend/src/iabank/models.py
        '**/backend/src/*/*/models.py', # iabank/backend/src/iabank/app/models.py
        '**/src/*/models.py',          # projeto/src/projeto/models.py
        '**/src/*/*/models.py',        # projeto/src/projeto/app/models.py
        '**/models.py',                # fallback
    ]
    
    for pattern in django_patterns:
        matches = list(Path('.').glob(pattern))
        # Filtrar apenas arquivos em diretórios que parecem apps Django
        django_models = [p for p in matches if p.is_file() and (p.parent / '__init__.py').exists()]
        models_files.extend(django_models)
    
    # Remover duplicatas mantendo ordem
    seen = set()
    models_files = [x for x in models_files if not (x in seen or seen.add(x))]
    
    found_models = set()
    
    for model_file in models_files:
        if model_file.exists():
            content = model_file.read_text(encoding='utf-8', errors='ignore')
            
            # Encontrar definições de classe que herdam de Model ou AbstractUser
            import re
            # Buscar classes que herdam de Model, AbstractUser, ou outros tipos Django
            class_patterns = [
                r'class (\\w+)\\([^)]*Model[^)]*\\):',      # Herda de Model
                r'class (\\w+)\\([^)]*AbstractUser[^)]*\\):', # Herda de AbstractUser  
                r'class (\\w+)\\([^)]*User[^)]*\\):',       # Herda de User
            ]
            
            class_matches = []
            for pattern in class_patterns:
                matches = re.findall(pattern, content)
                class_matches.extend(matches)
            for class_name in class_matches:
                if class_name in expected_models:
                    found_models.add(class_name)
    
    # Verificar modelos não encontrados
    missing_models = set(expected_models) - found_models
    for missing_model in missing_models:
        issues.append(ValidationIssue(
            file_path="models.py",
            issue_type="missing_blueprint_model",
            description=f"Modelo definido no Blueprint não encontrado: " + missing_model,
            expected=f"Classe " + missing_model + " deve estar implementada",
            actual="Modelo não existe",
            severity="HIGH"
        ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_all_blueprint_models",
            description="Valida todos os modelos definidos no Blueprint",
            code=rule_code.strip(),
            severity="HIGH",
            category="MODELS"
        ))

    def _generate_model_docstring_validation(self):
        """Valida se arquivos de modelos têm docstrings (escopo scaffolder)."""
        rule_code = """
def validate_model_files_docstrings():
    '''Valida se arquivos models.py têm docstrings de módulo obrigatórias.'''
    issues = []
    
    # Buscar models.py em estruturas Django típicas
    models_files = []
    django_patterns = [
        '**/backend/src/*/models.py',
        '**/backend/src/*/*/models.py', 
        '**/src/*/models.py',
        '**/src/*/*/models.py',
        '**/models.py',
    ]
    
    for pattern in django_patterns:
        matches = list(Path('.').glob(pattern))
        django_models = [p for p in matches if p.is_file() and (p.parent / '__init__.py').exists()]
        models_files.extend(django_models)
    
    seen = set()
    models_files = [x for x in models_files if not (x in seen or seen.add(x))]
    
    for model_file in models_files:
        if model_file.exists():
            content = model_file.read_text(encoding='utf-8', errors='ignore').strip()
            
            # Verificar se tem docstring de módulo no início
            has_docstring = content.startswith(chr(34)*3) or content.startswith(chr(39)*3)
            if not has_docstring:
                issues.append(ValidationIssue(
                    file_path=str(model_file),
                    issue_type="missing_module_docstring",
                    description=f"Arquivo models.py sem docstring de módulo: {model_file.name}",
                    expected="Arquivo deve começar com docstring de módulo explicando seu propósito",
                    actual="Docstring de módulo não encontrada",
                    severity="MEDIUM"
                ))
    
    return issues if issues else None
"""
            
        self.rules.append(ValidationRule(
            name="validate_model_files_docstrings",
            description="Valida docstrings obrigatórias em arquivos de modelos",
            code=rule_code.strip(),
            severity="MEDIUM",
            category="CONTENT"
        ))

    def _generate_apps_structure_validation(self):
        """Valida estrutura completa de apps Django - UNIVERSAL."""
        if not hasattr(self.specs, 'django_apps') or not self.specs.django_apps:
            return
            
        required_apps = list(self.specs.django_apps)
        
        rule_code = f"""
def validate_django_apps_structure():
    '''Valida estrutura completa de apps Django conforme Blueprint.'''
    issues = []
    required_apps = {required_apps}
    
    for app_name in required_apps:
        # Buscar apps Django de forma inteligente
        app_path = []
        
        # Padrões típicos de estrutura Django
        django_patterns = [
            '**/backend/src/*/' + app_name + '/',  # iabank/backend/src/iabank/app_name/
            '**/src/*/' + app_name + '/',          # projeto/src/projeto/app_name/
            '**/' + app_name + '/',                # projeto/app_name/ (fallback)
        ]
        
        for pattern in django_patterns:
            matches = list(Path('.').glob(pattern))
            # Filtrar apenas diretórios que parecem apps Django (têm __init__.py)
            django_apps = [p for p in matches if p.is_dir() and (p / '__init__.py').exists()]
            if django_apps:
                app_path = django_apps
                break
        
        app_found = False
        
        for app_dir in app_path:
            if app_dir.is_dir():
                app_found = True
                
                # Arquivos obrigatórios em cada app
                required_files = ['models.py', 'views.py', 'apps.py', '__init__.py']
                
                for req_file in required_files:
                    file_path = app_dir / req_file
                    if not file_path.exists():
                        issues.append(ValidationIssue(
                            file_path=str(file_path),
                            issue_type="missing_app_file",
                            description="Arquivo obrigatório não encontrado em app " + app_name + ": " + req_file,
                            expected="Arquivo " + req_file + " deve existir no app Django",
                            actual="Arquivo não existe",
                            severity="HIGH"
                        ))
                
                # Verificar diretório de testes
                tests_dir = app_dir / 'tests'
                if not tests_dir.exists():
                    issues.append(ValidationIssue(
                        file_path=str(tests_dir),
                        issue_type="missing_tests_directory",
                        description="Diretório de testes não encontrado no app " + app_name,
                        expected="Diretório tests/ deve existir no app",
                        actual="Diretório não existe",
                        severity="MEDIUM"
                    ))
        
        if not app_found:
            issues.append(ValidationIssue(
                file_path=app_name,
                issue_type="missing_django_app",
                description="App Django não encontrado: " + app_name,
                expected="App " + app_name + " deve estar implementado",
                actual="App não existe",
                severity="HIGH"
            ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_django_apps_structure",
            description="Valida estrutura completa de apps Django",
            code=rule_code.strip(),
            severity="HIGH",
            category="STRUCTURE"
        ))

    def _generate_frontend_basic_structure_validation(self):
        """Valida estrutura básica do frontend (escopo scaffolder)."""
        if self.specs.frontend_framework != "react":
            return
        
        rule_code = """
def validate_frontend_basic_structure():
    '''Valida estrutura básica do frontend conforme scaffolder.'''
    issues = []
    
    # Verificar se existe diretório frontend/src básico
    frontend_src = None
    for src_path in Path('.').rglob('**/src/'):
        parent = src_path.parent
        if (parent / 'package.json').exists():
            frontend_src = src_path
            break
    
    if not frontend_src:
        issues.append(ValidationIssue(
            file_path="frontend/src/",
            issue_type="missing_frontend_src",
            description="Diretório src/ não encontrado no frontend",
            expected="Estrutura frontend/src/ deve existir",
            actual="Diretório não existe",
            severity="HIGH"
        ))
    else:
        # Verificar arquivos básicos React (escopo scaffolder)
        basic_files = ['App.tsx', 'index.tsx', 'main.tsx']
        for basic_file in basic_files:
            file_path = frontend_src / basic_file
            if file_path.exists():
                # Verificar se tem comentário de cabeçalho
                content = file_path.read_text(encoding='utf-8', errors='ignore').strip()
                if not (content.startswith('/*') or content.startswith('//')):
                    issues.append(ValidationIssue(
                        file_path=str(file_path),
                        issue_type="missing_header_comment",
                        description=f"Arquivo React sem comentário de cabeçalho: {basic_file}",
                        expected="Arquivo deve começar com comentário explicando seu propósito",
                        actual="Comentário de cabeçalho não encontrado",
                        severity="MEDIUM"
                    ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_frontend_basic_structure",
            description="Valida estrutura básica do frontend",
            code=rule_code.strip(),
            severity="MEDIUM",
            category="CONTENT"
        ))

    def _generate_github_actions_validation(self):
        """Valida pipeline CI/CD completo - UNIVERSAL."""
        
        rule_code = """
def validate_github_actions_pipeline():
    '''Valida pipeline de CI/CD conforme Blueprint.'''
    issues = []
    
    # Verificar workflow do GitHub Actions
    workflow_paths = list(Path('.').rglob('**/.github/workflows/*.yml')) + \\
                    list(Path('.').rglob('**/.github/workflows/*.yaml'))
    
    if not workflow_paths:
        issues.append(ValidationIssue(
            file_path=".github/workflows/",
            issue_type="missing_ci_pipeline",
            description="Pipeline de CI/CD não encontrado",
            expected="Workflow GitHub Actions deve estar configurado",
            actual="Nenhum arquivo de workflow encontrado",
            severity="MEDIUM"
        ))
        return issues
    
    # Verificar conteúdo do workflow principal
    main_workflow = None
    for workflow in workflow_paths:
        content = workflow.read_text(encoding='utf-8', errors='ignore')
        if 'python' in content.lower() or 'node' in content.lower():
            main_workflow = workflow
            break
    
    if main_workflow:
        content = main_workflow.read_text(encoding='utf-8', errors='ignore')
        
        # Verificar steps essenciais
        essential_steps = ['test', 'lint', 'build']
        for step in essential_steps:
            if step not in content.lower():
                issues.append(ValidationIssue(
                    file_path=str(main_workflow),
                    issue_type="missing_ci_step",
                    description=f"Step essencial não encontrado no pipeline: " + step,
                    expected=f"Step '" + step + "' deve estar configurado no workflow",
                    actual="Step não configurado",
                    severity="MEDIUM"
                ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_github_actions_pipeline",
            description="Valida pipeline de CI/CD completo",
            code=rule_code.strip(),
            severity="MEDIUM",
            category="STRUCTURE"
        ))
    
    def _generate_docstring_validation_rules(self):
        """Gera validações de docstrings/comentários obrigatórios para arquivos de código."""
        
        # Validação de docstrings em arquivos Python (views.py, services.py, etc.)
        self._generate_python_files_docstring_validation()
        
        # Validação de comentários em arquivos React/TypeScript  
        self._generate_react_files_comment_validation()
    
    def _generate_python_files_docstring_validation(self):
        """Validação ULTRA-RIGOROSA de docstrings com QUALIDADE e ADEQUAÇÃO."""
        rule_code = """
def validate_python_files_docstrings():
    '''Valida QUALIDADE de docstrings conforme instruções scaffolder (certeza absoluta).'''
    issues = []
    
    # Tipos de arquivos Python que devem ter docstrings obrigatórias
    python_file_types = ['views.py', 'services.py', 'serializers.py', 'urls.py', 'apps.py', 'models.py']
    
    for file_type in python_file_types:
        python_files = list(Path('.').rglob(f'**/{file_type}'))
        # Filtrar apenas arquivos em apps Django (têm __init__.py no diretório)
        django_files = [f for f in python_files if (f.parent / '__init__.py').exists()]
        
        for python_file in django_files:
            if python_file.exists():
                content = python_file.read_text(encoding='utf-8', errors='ignore').strip()
                
                # Extrair docstring de módulo
                lines = content.split('\\n')
                docstring_content = None
                docstring_found = False
                
                for i, line in enumerate(lines):
                    line = line.strip()
                    if line.startswith(chr(34)*3) or line.startswith(chr(39)*3):
                        docstring_found = True
                        # Extrair conteúdo completo da docstring
                        quote_type = chr(34)*3 if line.startswith(chr(34)*3) else chr(39)*3
                        docstring_start = i
                        docstring_lines = []
                        
                        # Encontrar fim da docstring
                        for j in range(i, len(lines)):
                            if quote_type in lines[j] and j > i:
                                docstring_lines = lines[docstring_start:j+1]
                                break
                        
                        if docstring_lines:
                            docstring_content = '\\n'.join(docstring_lines)
                        break
                    elif (not line.startswith('from ') and 
                          not line.startswith('import ') and 
                          not line.startswith('#') and
                          line):
                        break  # Chegou ao código, parar de procurar
                
                # VALIDAÇÃO 1: Existência da docstring
                if not docstring_found:
                    issues.append(ValidationIssue(
                        file_path=str(python_file),
                        issue_type="missing_python_docstring",
                        description=f"Arquivo Python sem docstring de módulo: {python_file.name}",
                        expected="Docstring obrigatória conforme prompt scaffolder: 'explique seu propósito na arquitetura'",
                        actual="Docstring de módulo não encontrada",
                        severity="HIGH"
                    ))
                    continue
                
                # VALIDAÇÃO 2: Qualidade e adequação da docstring
                if docstring_content:
                    # Palavras-chave que devem aparecer para explicar propósito arquitetural
                    purpose_keywords = [
                        'módulo', 'app', 'aplicação', 'sistema', 'componente',
                        'gerencia', 'controla', 'define', 'implementa', 'contém'
                    ]
                    
                    architecture_keywords = [
                        'arquitetura', 'estrutura', 'framework', 'Django', 'modelo',
                        'view', 'serializer', 'service', 'API', 'endpoint'
                    ]
                    
                    docstring_lower = docstring_content.lower()
                    
                    # Verificar se explica propósito
                    has_purpose = any(keyword in docstring_lower for keyword in purpose_keywords)
                    has_architecture_context = any(keyword in docstring_lower for keyword in architecture_keywords)
                    
                    # Verificar tamanho mínimo (deve ser descritiva)
                    word_count = len(docstring_content.split())
                    
                    if word_count < 5:
                        issues.append(ValidationIssue(
                            file_path=str(python_file),
                            issue_type="insufficient_docstring_content",
                            description=f"Docstring muito curta em {python_file.name}: {word_count} palavras",
                            expected="Docstring deve explicar propósito na arquitetura conforme scaffolder",
                            actual=f"Apenas {word_count} palavras, insuficiente",
                            severity="MEDIUM"
                        ))
                    
                    if not has_purpose and not has_architecture_context:
                        issues.append(ValidationIssue(
                            file_path=str(python_file),
                            issue_type="inadequate_docstring_content",
                            description=f"Docstring inadequada em {python_file.name}: não explica propósito arquitetural",
                            expected="Docstring deve explicar 'seu propósito na arquitetura' conforme prompt scaffolder",
                            actual="Docstring não menciona propósito ou contexto arquitetural",
                            severity="MEDIUM"
                        ))
                
                # VALIDAÇÃO 3: Posicionamento correto (primeiro elemento após imports)
                non_import_lines = [line for line in lines if line.strip() and 
                                  not line.strip().startswith('from ') and 
                                  not line.strip().startswith('import ') and
                                  not line.strip().startswith('#')]
                
                if non_import_lines and not non_import_lines[0].strip().startswith(chr(34)*3):
                    if not non_import_lines[0].strip().startswith(chr(39)*3):
                        issues.append(ValidationIssue(
                            file_path=str(python_file),
                            issue_type="misplaced_docstring",
                            description=f"Docstring mal posicionada em {python_file.name}",
                            expected="Docstring deve ser primeiro elemento após imports",
                            actual="Docstring não está no início do código",
                            severity="MEDIUM"
                        ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_python_files_docstrings",
            description="Valida docstrings obrigatórias em arquivos Python",
            code=rule_code.strip(),
            severity="MEDIUM",
            category="CONTENT"
        ))
    
    def _generate_react_files_comment_validation(self):
        """Valida comentários obrigatórios em arquivos React/TypeScript."""
        if self.specs.frontend_framework != "react":
            return
            
        rule_code = """
def validate_react_files_comments():
    '''Valida se arquivos React/TypeScript têm comentários de cabeçalho.'''
    issues = []
    
    # Tipos de arquivos React que devem ter comentários  
    react_file_patterns = ['**/*.tsx', '**/*.ts', '**/*.jsx', '**/*.js']
    
    # Buscar em diretório frontend
    frontend_src = None
    for src_path in Path('.').rglob('**/src/'):
        parent = src_path.parent
        if (parent / 'package.json').exists():
            frontend_src = src_path.parent
            break
    
    if not frontend_src:
        return None
    
    for pattern in react_file_patterns:
        react_files = list(frontend_src.rglob(pattern))
        
        for react_file in react_files:
            # Focar apenas em arquivos principais (App, main, index)
            if any(key in react_file.name for key in ['App.', 'main.', 'index.']):
                content = react_file.read_text(encoding='utf-8', errors='ignore').strip()
                
                # Verificar se tem comentário de cabeçalho
                lines = content.split('\\n')[:5]  # Primeiras 5 linhas
                comment_found = any(
                    line.strip().startswith('/*') or 
                    line.strip().startswith('//') or
                    line.strip().startswith('*')
                    for line in lines
                )
                
                if not comment_found:
                    issues.append(ValidationIssue(
                        file_path=str(react_file),
                        issue_type="missing_react_comment",
                        description=f"Arquivo React sem comentário de cabeçalho: {react_file.name}",
                        expected="Arquivo deve começar com comentário explicando seu propósito conforme scaffolder",
                        actual="Comentário de cabeçalho não encontrado",
                        severity="MEDIUM"
                    ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_react_files_comments",
            description="Valida comentários obrigatórios em arquivos React/TypeScript",
            code=rule_code.strip(),
            severity="MEDIUM",
            category="CONTENT"
        ))
    
    def _generate_absolute_structure_validation_rules(self):
        """Validações ABSOLUTAS de estrutura completa para certeza total."""
        
        # Validação de estrutura frontend detalhada
        self._generate_detailed_frontend_structure_validation()
        
        # Validação de conformidade total com prompt scaffolder
        self._generate_scaffolder_prompt_compliance_validation()
    
    def _generate_detailed_frontend_structure_validation(self):
        """Validação DETALHADA da estrutura frontend conforme Blueprint seção 4."""
        rule_code = """
def validate_detailed_frontend_structure():
    '''Valida estrutura frontend COMPLETA conforme Blueprint seção 4 (certeza absoluta).'''
    issues = []
    
    # Buscar diretório frontend
    frontend_src = None
    for src_path in Path('.').rglob('**/src/'):
        parent = src_path.parent
        if (parent / 'package.json').exists():
            frontend_src = src_path
            break
    
    if not frontend_src:
        issues.append(ValidationIssue(
            file_path="frontend/src/",
            issue_type="missing_frontend_directory",
            description="Diretório frontend/src/ não encontrado",
            expected="Estrutura frontend completa conforme Blueprint seção 4",
            actual="Diretório frontend não existe",
            severity="CRITICAL"
        ))
        return issues
    
    # Estrutura EXATA esperada do Blueprint seção 4
    expected_structure = {
        'app/': [
            # Configuração global da aplicação (providers, store, router, styles)
        ],
        'pages/': [
            # Componentes de página, que compõem layouts a partir das features
        ],
        'features/': [
            # Funcionalidades de negócio (ex: loan-list, customer-form)
            'loan-list/', 'customer-form/'
        ],
        'entities/': [
            # Componentes e lógica de entidades de negócio (ex: LoanCard, CustomerAvatar)
        ],
        'shared/': [
            'api/',      # Configuração do cliente Axios/Fetch global
            'config/',   # Constantes, configurações de ambiente
            'lib/',      # Funções utilitárias, helpers, hooks genéricos
            'ui/'        # Biblioteca de componentes de UI puros (Button, Input, Table)
        ]
    }
    
    # Validar estrutura principal obrigatória
    for main_dir in expected_structure.keys():
        dir_path = frontend_src / main_dir
        if not dir_path.exists():
            issues.append(ValidationIssue(
                file_path=str(dir_path),
                issue_type="missing_frontend_main_directory",
                description=f"Diretório principal ausente: {main_dir}",
                expected=f"Diretório '{main_dir}' é OBRIGATÓRIO conforme Blueprint seção 4",
                actual="Diretório principal não existe",
                severity="HIGH"
            ))
        else:
            # Validar subdiretórios específicos para shared/
            if main_dir == 'shared/' and expected_structure[main_dir]:
                for sub_dir in expected_structure[main_dir]:
                    sub_path = dir_path / sub_dir
                    if not sub_path.exists():
                        issues.append(ValidationIssue(
                            file_path=str(sub_path),
                            issue_type="missing_frontend_sub_directory",
                            description=f"Subdiretório shared ausente: {sub_dir}",
                            expected=f"Subdiretório shared/{sub_dir} conforme Blueprint",
                            actual="Subdiretório não existe",
                            severity="MEDIUM"
                        ))
    
    # Validar arquivos React principais (se existem e têm comentários)
    main_files = ['App.tsx', 'main.tsx', 'index.tsx']
    for main_file in main_files:
        file_path = frontend_src / main_file
        if file_path.exists():
            content = file_path.read_text(encoding='utf-8', errors='ignore')
            # Verificar se é apenas arquivo com comentário (escopo scaffolder)
            lines = content.strip().split('\\n')[:5]
            has_substantial_content = any(
                line.strip() and 
                not line.strip().startswith('//') and 
                not line.strip().startswith('/*') and
                not line.strip().startswith('*') and
                not line.strip().startswith('import') and
                not line.strip().startswith('export')
                for line in lines
            )
            
            # Para scaffolder, arquivos devem ter principalmente comentários
            if has_substantial_content:
                # Isso é bom - mas vamos verificar se ainda tem comentário
                has_comment = any(
                    line.strip().startswith('//') or 
                    line.strip().startswith('/*') or
                    line.strip().startswith('*')
                    for line in lines
                )
                
                if not has_comment:
                    issues.append(ValidationIssue(
                        file_path=str(file_path),
                        issue_type="missing_react_header_comment",
                        description=f"Arquivo React principal sem comentário: {main_file}",
                        expected="Comentário de cabeçalho conforme prompt scaffolder",
                        actual="Nenhum comentário encontrado",
                        severity="MEDIUM"
                    ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_detailed_frontend_structure",
            description="Valida estrutura frontend detalhada conforme Blueprint seção 4",
            code=rule_code.strip(),
            severity="HIGH",
            category="STRUCTURE"
        ))
    
    def _generate_scaffolder_prompt_compliance_validation(self):
        """Validação ABSOLUTA de conformidade com prompt do scaffolder."""
        rule_code = """
def validate_scaffolder_prompt_compliance():
    '''Valida conformidade ABSOLUTA com instruções do prompt scaffolder (certeza 100%).'''
    issues = []
    
    # REGRA 1: Arquivos de código devem ter APENAS docstrings/comentários
    # (não devem ter implementação de lógica de negócio)
    
    critical_files = ['models.py', 'views.py', 'services.py', 'serializers.py']
    
    for file_type in critical_files:
        python_files = list(Path('.').rglob(f'**/{file_type}'))
        django_files = [f for f in python_files if (f.parent / '__init__.py').exists()]
        
        for python_file in django_files:
            if python_file.exists():
                content = python_file.read_text(encoding='utf-8', errors='ignore')
                lines = content.split('\\n')
                
                # Contar linhas de código real (excluindo imports, docstrings, comentários)
                code_lines = []
                in_docstring = False
                docstring_quote = None
                
                for line in lines:
                    stripped = line.strip()
                    
                    # Pular linhas vazias
                    if not stripped:
                        continue
                    
                    # Detectar início/fim de docstring
                    if stripped.startswith(chr(34)*3) or stripped.startswith(chr(39)*3):
                        if not in_docstring:
                            in_docstring = True
                            docstring_quote = chr(34)*3 if stripped.startswith(chr(34)*3) else chr(39)*3
                        elif docstring_quote in stripped and len(stripped) > 3:
                            in_docstring = False
                        continue
                    
                    # Pular se dentro de docstring
                    if in_docstring:
                        continue
                    
                    # Pular imports e comentários
                    if (stripped.startswith('from ') or 
                        stripped.startswith('import ') or 
                        stripped.startswith('#')):
                        continue
                    
                    # Esta é uma linha de código real
                    code_lines.append(stripped)
                
                # VALIDAÇÃO: Arquivos devem ter implementação mínima (apenas estrutura)
                # Para scaffolder, esperamos principalmente docstrings e estrutura básica
                
                significant_code_lines = [
                    line for line in code_lines 
                    if line and not line.startswith('class ') and 
                    not line.startswith('def ') and
                    not line.startswith('pass') and
                    line != '...'
                ]
                
                # Se há muitas linhas de implementação real, pode estar além do escopo scaffolder
                if len(significant_code_lines) > 10:  # Tolerância para estrutura básica
                    issues.append(ValidationIssue(
                        file_path=str(python_file),
                        issue_type="excessive_implementation_for_scaffold",
                        description=f"Arquivo {file_type} com implementação excessiva: {len(significant_code_lines)} linhas",
                        expected="Scaffolder deve criar apenas docstrings e estrutura básica",
                        actual=f"Arquivo contém {len(significant_code_lines)} linhas de implementação",
                        severity="MEDIUM"
                    ))
    
    # REGRA 2: Verificar se documentos essenciais têm conteúdo apropriado para scaffolder
    essential_docs = {
        'README.md': ['IABANK', 'Docker', 'setup'],
        'CONTRIBUTING.md': ['contribuir', 'desenvolvimento', 'qualidade'],
        'CHANGELOG.md': ['changes', 'version', 'changelog']
    }
    
    for doc_file, expected_content in essential_docs.items():
        doc_paths = list(Path('.').rglob(f'**/{doc_file}'))
        if doc_paths:
            content = doc_paths[0].read_text(encoding='utf-8', errors='ignore').lower()
            missing_elements = [elem for elem in expected_content if elem.lower() not in content]
            
            if len(missing_elements) >= len(expected_content) // 2:  # Mais da metade ausente
                issues.append(ValidationIssue(
                    file_path=str(doc_paths[0]),
                    issue_type="inadequate_documentation_content",
                    description=f"Documentação {doc_file} inadequada para scaffolder",
                    expected=f"Deve conter elementos: {', '.join(expected_content)}",
                    actual=f"Elementos ausentes: {', '.join(missing_elements)}",
                    severity="MEDIUM"
                ))
    
    # REGRA 3: Estrutura de testes deve existir mas sem implementação
    test_dirs = list(Path('.').rglob('**/tests/'))
    if not test_dirs:
        issues.append(ValidationIssue(
            file_path="tests/",
            issue_type="missing_test_structure",
            description="Estrutura de testes não encontrada",
            expected="Scaffolder deve criar estrutura de testes conforme Blueprint",
            actual="Nenhum diretório tests/ encontrado",
            severity="MEDIUM"
        ))
    
    return issues if issues else None
"""
        
        self.rules.append(ValidationRule(
            name="validate_scaffolder_prompt_compliance",
            description="Valida conformidade absoluta com instruções do prompt scaffolder",
            code=rule_code.strip(),
            severity="HIGH",
            category="CONTENT"
        ))